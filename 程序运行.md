# 程序如何运行？

## 批处理

> **RISC-V 寄存器编号和别名**
> RISC-V 寄存器编号从`0~31`，表示为`x0~x31`。其中：
>
> * `x10~x17`：对应`a0~a7`
> * `x1`：对应`ra`

### USER程序

```shell
user
    ├── .cargo
    │   └── config.toml   (调整内存布局)
    ├── Cargo.lock
    ├── Cargo.toml
    ├── Makefile
    ├── src
    │   ├── bin           (存放应用程序)
    │   ├── lang_items.rs ()
    │   ├── console.rs    (具体功能，write_str/......)
    │   ├── lib.rs        (系统功能，write/exit/......)
    │   ├── syscall.rs    (系统调用，"ecall"->syscall->sys_*)
    │   └── linker.ld     (应用程序的内存布局)
    └── target
        ├── .rustc_info.json
        ├── CACHEDIR.TAG
        ├── release
        └── riscv64gc-unknown-none-elf
```

#### 👀️内存布局

> 首先在`user/src/linker.ld`文件中编写好链接脚本，再通过`user/.cargo/config`去声明使用链接脚本

1. `user/src/linker.ld`

   ```linker
   OUTPUT_ARCH(riscv)
   ENTRY(_start)

   BASE_ADDRESS = 0x80400000;

   SECTIONS
   {
       . = BASE_ADDRESS;
       .text : {
           *(.text.entry)
           *(.text .text.*)
       }
       .rodata : {
           *(.rodata .rodata.*)
           *(.srodata .srodata.*)
       }
       .data : {
           *(.data .data.*)
           *(.sdata .sdata.*)
       }
       .bss : {
           start_bss = .;
           *(.bss .bss.*)
           *(.sbss .sbss.*)
           end_bss = .;
       }
       /DISCARD/ : {
           *(.eh_frame)
           *(.debug*)
       }
   }
   ```
2. `user/.cargo/config`

   ```toml
   [build]
   target = "riscv64gc-unknown-none-elf"

   [target.riscv64gc-unknown-none-elf]
   rustflags = [
       "-Clink-args=-Tsrc/linker.ld", "-Cforce-frame-pointers=yes"
   ]

   ```

#### 👀️系统调用

```rust
/// 功能：将内存中缓冲区中的数据写入文件。
/// 参数：`fd` 表示待写入文件的文件描述符；
///      `buf` 表示内存中缓冲区的起始地址；
///      `len` 表示内存中缓冲区的长度。
/// 返回值：返回成功写入的长度。
/// syscall ID：64
fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize;

/// 功能：退出应用程序并将返回值告知批处理系统。
/// 参数：`exit_code` 表示应用程序的返回值。
/// 返回值：该系统调用不应该返回。
/// syscall ID：93
fn sys_exit(exit_code: usize) -> !;
```

```rust
fn program1() {//-bin-应用程序
    pub fn write_str() {//-console.rs-具体功能
        pub fn write() {//-lib.rs-系统功能
            pub fn sys_write() {//-syscall.rs-系统调用
                pub fn syscall() {//-syscall.rs-系统调用
                    "ecall"; //汇编
                }
            }
        }
    }
}
```









## 多道 + 协作式

## 多道 + 抢夺式
